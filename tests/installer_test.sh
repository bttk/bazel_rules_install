#!/bin/bash
# Copyright 2018 The Bazel Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -o pipefail -o errexit -o nounset

# installer rule outut
declare -r INSTALLER="$1"
# srcs attribute of installer rule
declare -r FILE="$2"
# target_subdir attribute of installer rule
declare -r SUBDIR="${3:-}"

function error() {
  echo >&2 "$@"
  exit 1
}

function setup() {
  [[ -r "${FILE}" ]] ||
    error "Can't read ${FILE}"
  [[ -x "${INSTALLER}" ]] ||
    error "Can't run ${INSTALLER}"
  mktemp --directory --tmpdir="${TEST_TMPDIR}"
}

function test_basic_install() {
  local tmpdir="$1"

  if ! "${INSTALLER}" -g "${tmpdir}"; then
    echo >&2 "installer didn't exit with code 0"
    return 1
  fi

  local expected_path
  if [[ -n "${SUBDIR}" ]]; then
    expected_path="${tmpdir}/${SUBDIR}/$(basename "${FILE}")"
  else
    expected_path="${tmpdir}/$(basename "${FILE}")"
  fi

  if [[ ! -f "${expected_path}" ]]; then
    echo >&2 "expected file ${expected_path} doesn't exist"
    return 1
  fi

  local mode
  mode="$(stat --dereference --format=%a "${expected_path}")"
  local expected_mode
  expected_mode="$(stat --dereference --format=%a "${FILE}")"
  if [[ "${mode}" != "${expected_mode}" ]]; then
    echo >&2 "mode of file ${expected_path} (${expected_mode}) do not match ${FILE} (${mode})"
    return 1
  fi

  if ! diff -q "${FILE}" "${expected_path}"; then
    echo >&2 "contents of file ${expected_path} do not match ${FILE}"
    return 1
  fi

}

function test_prefix_install() {
  local tmpdir="$1"

  if ! "${INSTALLER}" -g "${tmpdir}/a/b/c"; then
    echo >&2 "installer didn't exit with code 0"
    return 1
  fi

  local expected_path
  if [[ -n "${SUBDIR}" ]]; then
    expected_path="${tmpdir}/a/b/c/${SUBDIR}/$(basename "${FILE}")"
  else
    expected_path="${tmpdir}/a/b/c/$(basename "${FILE}")"
  fi

  if [[ ! -f "${expected_path}" ]]; then
    echo >&2 "expected file ${expected_path} doesn't exist"
    return 1
  fi

  local mode
  mode="$(stat --dereference --format=%a "${expected_path}")"
  local expected_mode
  expected_mode="$(stat --dereference --format=%a "${FILE}")"
  if [[ "${mode}" != "${expected_mode}" ]]; then
    echo >&2 "mode of file ${expected_path} (${expected_mode}) do not match ${FILE} (${mode})"
    return 1
  fi

  if ! diff -q "${FILE}" "${expected_path}"; then
    echo >&2 "contents of file ${expected_path} do not match ${FILE}"
    return 1
  fi

}

function test_generated_warning() {
  if ! grep -q "DO NOT EDIT THIS FILE" "${INSTALLER}"; then
    echo >&2 "installer doesn't have a DO NOT EDIT warning"
    exit 1
  fi
  if grep "@@.*@@" "${INSTALLER}" >&2; then
    echo >&2 "installer seems to contain unassigned template variables"
    exit 1
  fi
}

function main() {
  local tmpdir
  local test
  for test in test_basic_install test_prefix_install test_generated_warning; do
    tmpdir="$(setup)"
    if "${test}" "${tmpdir}"; then
      echo "Passed ${test}"
    else
      echo "Failed ${test}"
      exit 1
    fi
  done
}

main
